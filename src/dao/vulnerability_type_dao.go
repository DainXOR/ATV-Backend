package dao

import (
	"dainxor/atv/configs"
	"dainxor/atv/logger"
	"dainxor/atv/models"
	"dainxor/atv/types"
	"dainxor/atv/utils"
)

type vulnerabilityTypeType struct{}

var VulnerabilityType vulnerabilityTypeType

func (vulnerabilityTypeType) Create(u models.VulnerabilityTypeCreate) types.Result[models.VulnerabilityTypeDB] {
	vulnerabilityTypeDB := u.ToInsert()
	resultID := configs.DB.InsertOne(vulnerabilityTypeDB)

	if resultID.IsErr() {
		logger.Warning("Error inserting vulnerability type: ", resultID.Error())
		return types.ResultErr[models.VulnerabilityTypeDB](resultID.Error())
	}

	vulnerabilityTypeDB.ID = resultID.Value()
	return types.ResultOk(vulnerabilityTypeDB)
}

func (vulnerabilityTypeType) GetByID(id string, filter models.FilterObject) types.Result[models.VulnerabilityTypeDB] {
	oid, err := models.ID.ToDB(id)

	if err != nil {
		logger.Error("Failed to convert ID to ObjectID: ", err)
		httpErr := types.Error(
			types.Http.C400().UnprocessableEntity(),
			"Invalid value",
			"Invalid ID format: "+err.Error(),
			"VulnerabilityType ID: "+id,
		)
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	filter = models.Filter.AddPart(filter, models.Filter.ID(oid))
	filter = models.Filter.AddPart(filter, models.Filter.NotDeleted())
	resultVulnerabilityType := configs.DB.FindOne(filter, models.VulnerabilityTypeDB{})
	if resultVulnerabilityType.IsErr() {
		logger.Warning("Failed to get vulnerability type by ID: ", resultVulnerabilityType.Error())
		var httpErr types.HttpError

		switch resultVulnerabilityType.Error() {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to retrieve vulnerability type",
				resultVulnerabilityType.Error().Error(),
				"VulnerabilityType ID: "+id,
			)
		}

		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	return types.ResultOk(resultVulnerabilityType.Value().(models.VulnerabilityTypeDB))
}
func (vulnerabilityTypeType) GetAll(filter models.FilterObject) types.Result[[]models.VulnerabilityTypeDB] {
	filter = models.Filter.AddPart(filter, models.Filter.NotDeleted())

	resultVulnerabilityTypes := configs.DB.FindAll(filter, models.VulnerabilityTypeDB{})
	if resultVulnerabilityTypes.IsErr() {
		logger.Warning("Failed to get all vulnerability types from MongoDB:", resultVulnerabilityTypes.Error())
		return types.ResultErr[[]models.VulnerabilityTypeDB](resultVulnerabilityTypes.Error())
	}

	vulnerabilityTypes := utils.Map(resultVulnerabilityTypes.Value(), models.InterfaceTo[models.VulnerabilityTypeDB])
	logger.Debug("Retrieved", len(vulnerabilityTypes), "vulnerability types from MongoDB database")
	return types.ResultOk(vulnerabilityTypes)
}

func (vulnerabilityTypeType) UpdateByID(id string, vulnerabilityType models.VulnerabilityTypeCreate, filter models.FilterObject) types.Result[models.VulnerabilityTypeDB] {
	oid, err := models.ID.ToDB(id)
	if err != nil {
		logger.Warning("Failed to convert ID to ObjectID: ", err)
		httpErr := types.Error(
			types.Http.C400().UnprocessableEntity(),
			"Invalid value",
			"Invalid ID format: "+err.Error(),
			"VulnerabilityType ID: "+id,
		)
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	vulnerabilityTypeUpdate := vulnerabilityType.ToUpdate()

	filter = models.Filter.AddPart(filter, models.Filter.ID(oid))
	filter = models.Filter.AddPart(filter, models.Filter.NotDeleted())
	err = configs.DB.UpdateOne(filter, vulnerabilityTypeUpdate)
	if err != nil {
		logger.Warning("Failed to update vulnerabilityType in database: ", err)
		var httpErr types.HttpError

		switch err {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to update vulnerabilityType",
				err.Error(),
				"VulnerabilityType ID: "+id,
			)
		}
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	resultVulnerabilityTypeDB := configs.DB.FindOne(filter, models.VulnerabilityTypeDB{})
	if resultVulnerabilityTypeDB.IsErr() {
		logger.Warning("Failed to retrieve updated vulnerabilityType: ", resultVulnerabilityTypeDB.Error())
		var httpErr types.HttpError

		switch resultVulnerabilityTypeDB.Error() {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to retrieve updated vulnerabilityType",
				resultVulnerabilityTypeDB.Error().Error(),
				"VulnerabilityType ID: "+id,
			)
		}
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	return types.ResultOk(resultVulnerabilityTypeDB.Value().(models.VulnerabilityTypeDB))
}

func (vulnerabilityTypeType) PatchByID(id string, vulnerabilityType models.VulnerabilityTypeCreate, filter models.FilterObject) types.Result[models.VulnerabilityTypeDB] {
	oid, err := models.ID.ToDB(id)
	if err != nil {
		logger.Warning("Failed to convert ID to ObjectID: ", err)
		httpErr := types.Error(
			types.Http.C400().UnprocessableEntity(),
			"Invalid value",
			"Invalid ID format: "+err.Error(),
			"VulnerabilityType ID: "+id,
		)
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	vulnerabilityTypePatch := vulnerabilityType.ToUpdate()

	filter = models.Filter.AddPart(filter, models.Filter.ID(oid))
	filter = models.Filter.AddPart(filter, models.Filter.NotDeleted())
	err = configs.DB.PatchOne(filter, vulnerabilityTypePatch)
	if err != nil {
		logger.Warning("Failed to patch vulnerabilityType in database: ", err)
		var httpErr types.HttpError

		switch err {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to patch vulnerabilityType",
				err.Error(),
				"VulnerabilityType ID: "+id,
			)
		}
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	resultVulnerabilityTypeDB := configs.DB.FindOne(filter, models.VulnerabilityTypeDB{})
	if resultVulnerabilityTypeDB.IsErr() {
		logger.Warning("Failed to retrieve updated vulnerabilityType: ", resultVulnerabilityTypeDB.Error())
		var httpErr types.HttpError

		switch resultVulnerabilityTypeDB.Error() {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to retrieve updated vulnerabilityType",
				resultVulnerabilityTypeDB.Error().Error(),
				"VulnerabilityType ID: "+id,
			)
		}
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	return types.ResultOk(resultVulnerabilityTypeDB.Value().(models.VulnerabilityTypeDB))
}

func (vulnerabilityTypeType) DeleteByID(id string, filter models.FilterObject) types.Result[models.VulnerabilityTypeDB] {
	oid, err := models.ID.ToDB(id)
	if err != nil {
		logger.Warning("Failed to convert ID to ObjectID: ", err)
		httpErr := types.Error(
			types.Http.C400().UnprocessableEntity(),
			"Invalid value",
			"Invalid ID format: "+err.Error(),
			"VulnerabilityType ID: "+id,
		)
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	filter = models.Filter.AddPart(filter, models.Filter.ID(oid))
	filter = models.Filter.AddPart(filter, models.Filter.NotDeleted())
	resultVulnerabilityType := configs.DB.FindOne(filter, models.VulnerabilityTypeDB{})
	if resultVulnerabilityType.IsErr() {
		logger.Warning("Failed to retrieve vulnerabilityType: ", resultVulnerabilityType.Error())
		var httpErr types.HttpError

		switch resultVulnerabilityType.Error() {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to retrieve vulnerabilityType",
				resultVulnerabilityType.Error().Error(),
				"VulnerabilityType ID: "+id,
			)
		}

		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	deletedVulnerabilityType := resultVulnerabilityType.Value().(models.VulnerabilityTypeDB)
	err = configs.DB.SoftDeleteOne(filter, deletedVulnerabilityType)
	if err != nil {
		logger.Warning("Failed to delete vulnerabilityType in database: ", err)
		var httpErr types.HttpError

		switch err {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found",
			)

		case configs.DBErr.NotModified():
			httpErr = types.Error(
				types.Http.C400().PreconditionFailed(),
				"VulnerabilityType was already marked as deleted",
				"VulnerabilityType ID: "+id,
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to delete vulnerabilityType",
				err.Error(),
				"VulnerabilityType ID: "+id,
			)
		}

		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	return types.ResultOk(deletedVulnerabilityType)
}
func (vulnerabilityTypeType) DeletePermanentByID(id string, filter models.FilterObject) types.Result[models.VulnerabilityTypeDB] {
	logger.Warning("Permanently deleting vulnerabilityType by ID: ", id)
	oid, err := models.ID.ToDB(id)
	if err != nil {
		logger.Warning("Failed to convert ID to ObjectID: ", err)
		httpErr := types.Error(
			types.Http.C400().UnprocessableEntity(),
			"Invalid value",
			"Invalid ID format: "+err.Error(),
			"VulnerabilityType ID: "+id,
		)
		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	filter = models.Filter.AddPart(filter, models.Filter.ID(oid))
	filter = models.Filter.AddPart(filter, models.Filter.Deleted())
	resultVulnerabilityType := configs.DB.FindOne(filter, models.VulnerabilityTypeDB{})
	if resultVulnerabilityType.IsErr() {
		logger.Warning("Failed to find vulnerabilityType for permanent deletion: ", resultVulnerabilityType.Error())
		var httpErr types.HttpError

		switch resultVulnerabilityType.Error() {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found or not marked as deleted",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to find vulnerabilityType for permanent deletion",
				resultVulnerabilityType.Error().Error(),
				"VulnerabilityType ID: "+id,
			)
		}

		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	err = configs.DB.PermanentDeleteOne(filter, models.VulnerabilityTypeDB{})
	if err != nil {
		logger.Warning("Failed to permanently delete vulnerabilityType in database: ", err)
		var httpErr types.HttpError

		switch err {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityType not found",
				"VulnerabilityType with ID "+id+" not found or not marked as deleted",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to permanently delete vulnerabilityType",
				err.Error(),
				"VulnerabilityType ID: "+id,
			)
		}

		return types.ResultErr[models.VulnerabilityTypeDB](&httpErr)
	}

	return types.ResultOk(resultVulnerabilityType.Value().(models.VulnerabilityTypeDB))
}
func (vulnerabilityTypeType) DeletePermanentAll(filter models.FilterObject) types.Result[[]models.VulnerabilityTypeDB] {
	filter = models.Filter.AddPart(filter, models.Filter.Deleted())

	resultVulnerabilityTypes := configs.DB.FindAll(filter, models.VulnerabilityTypeDB{})
	if resultVulnerabilityTypes.IsErr() {
		logger.Warning("Failed to find vulnerabilityType for permanent deletion: ", resultVulnerabilityTypes.Error())
		var httpErr types.HttpError

		switch resultVulnerabilityTypes.Error() {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityTypes not found",
				"No vulnerabilityTypes marked as deleted found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to find vulnerabilityType for permanent deletion",
				resultVulnerabilityTypes.Error().Error(),
			)
		}

		return types.ResultErr[[]models.VulnerabilityTypeDB](&httpErr)
	}

	err := configs.DB.PermanentDeleteMany(filter, models.VulnerabilityTypeDB{})
	if err != nil {
		logger.Warning("Failed to permanently delete all vulnerabilityTypes in database: ", err)
		var httpErr types.HttpError

		switch err {
		case configs.DBErr.NotFound():
			httpErr = types.ErrorNotFound(
				"VulnerabilityTypes not found",
				"No vulnerabilityTypes marked as deleted found",
			)

		default:
			httpErr = types.ErrorInternal(
				"Failed to permanently delete all vulnerabilityTypes",
				err.Error(),
			)
		}
		return types.ResultErr[[]models.VulnerabilityTypeDB](&httpErr)
	}

	vulnerabilityTypes := utils.Map(resultVulnerabilityTypes.Value(), models.InterfaceTo[models.VulnerabilityTypeDB])
	return types.ResultOk(vulnerabilityTypes)
}
