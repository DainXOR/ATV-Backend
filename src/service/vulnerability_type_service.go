package service

import (
	"dainxor/atv/db"
	"dainxor/atv/logger"
	"dainxor/atv/models"
	"dainxor/atv/types"
	"dainxor/atv/utils"

	"github.com/gin-gonic/gin"
)

type vulnerabilityTypeType struct{}

var VulnerabilityType vulnerabilityTypeType

func (vulnerabilityTypeType) Create(c *gin.Context) {
	var body models.VulnerabilityTypeCreate

	if err := c.ShouldBindJSON(&body); err != nil {
		expected := utils.StructToString(body)
		logger.Warning(err.Error())
		logger.Warning("Failed to create vulnerability type: JSON request body is invalid")
		logger.Warning("Expected body: ", expected)

		c.JSON(types.Http.C400().BadRequest(),
			types.EmptyResponse(
				"Invalid request body",
				"Expected body: "+expected,
			),
		)
		return
	}

	logger.Debug("Creating vulnerability type in MongoDB: ", body)
	existent := db.VulnerabilityType.GetAll(models.Filter.Empty())
	if existent.IsOk() && len(existent.Value()) > 0 {
		match := utils.Any(existent.Value(), func(st models.VulnerabilityTypeDB) bool {
			return st.Name == body.Name
		})

		if match {
			logger.Info("Vulnerability type with the name already exists: ", body.Name)
			c.JSON(types.Http.C400().Conflict(),
				types.EmptyResponse(
					"Vulnerability type with this name already exists",
					"Name: "+body.Name,
				),
			)
			return
		}
	}

	result := db.VulnerabilityType.Create(body)

	if result.IsErr() {
		logger.Error("Failed to create vulnerability type in MongoDB: ", result.Error())
		err := result.Error()
		httpErr := err.(*types.HttpError)
		c.JSON(httpErr.Code,
			types.EmptyResponse(
				httpErr.Msg(),
				httpErr.Details(),
			),
		)
		return
	}

	vulnerabilityType := result.Value()
	c.JSON(types.Http.C200().Created(),
		types.Response(
			vulnerabilityType.ToResponse(),
			"",
		),
	)
}

func (vulnerabilityTypeType) GetByID(c *gin.Context) {
	id := c.Param("id")
	logger.Debug("Getting vulnerability type by ID: ", id)
	filter := models.Filter.Create(c.Request.URL.Query())

	result := db.VulnerabilityType.GetByID(id, filter)

	if result.IsErr() {
		err := result.Error()
		cerror := err.(*types.HttpError)
		c.JSON(cerror.Code,
			types.EmptyResponse(
				cerror.Msg(),
				cerror.Details(),
			),
		)
		return
	}

	vulnerabilityType := result.Value()
	c.JSON(types.Http.C200().Ok(),
		types.Response(
			vulnerabilityType.ToResponse(),
			"",
		),
	)
}
func (vulnerabilityTypeType) GetAll(c *gin.Context) {
	filter := models.Filter.Create(c.Request.URL.Query())
	result := db.VulnerabilityType.GetAll(filter)

	if result.IsErr() {
		err := result.Error().(*types.HttpError)
		c.JSON(err.Code,
			types.EmptyResponse(
				err.Msg(),
				err.Details(),
			),
		)
		return
	}

	vulnerabilityTypes := utils.Map(result.Value(), models.VulnerabilityTypeDB.ToResponse)
	if len(vulnerabilityTypes) == 0 {
		logger.Warning("No vulnerability types found in database")
		c.JSON(types.Http.C400().NotFound(),
			types.EmptyResponse(
				"No vulnerability types found",
			))
		return
	}
	c.JSON(types.Http.C200().Ok(),
		types.Response(
			vulnerabilityTypes,
			"",
		),
	)
}

func (vulnerabilityTypeType) UpdateByID(c *gin.Context) {
	var body models.VulnerabilityTypeCreate

	if err := c.ShouldBindJSON(&body); err != nil {
		expected := utils.StructToString(body)
		logger.Error(err.Error())
		logger.Error("Failed to update vulnerabilityType: JSON request body is invalid")
		logger.Error("Expected body: ", expected)

		c.JSON(types.Http.C400().BadRequest(),
			types.EmptyResponse(
				"Invalid request body",
				"Expected body: "+expected,
			),
		)
		return
	}

	id := c.Param("id")
	logger.Debug("Updating vulnerabilityType by ID: ", id)
	filter := models.Filter.Create(c.Request.URL.Query())

	result := db.VulnerabilityType.UpdateByID(id, body, filter)
	if result.IsErr() {
		err := result.Error()
		cerror := err.(*types.HttpError)
		c.JSON(cerror.Code, err)
		return
	}

	vulnerabilityType := result.Value()
	c.JSON(types.Http.C200().Ok(),
		types.Response(
			vulnerabilityType.ToResponse(),
			"",
		),
	)
}

func (vulnerabilityTypeType) PatchByID(c *gin.Context) {
	var body models.VulnerabilityTypeCreate

	if err := c.ShouldBindJSON(&body); err != nil {
		expected := utils.StructToString(body)
		logger.Error(err.Error())
		logger.Error("Failed to patch vulnerabilityType: JSON request body is invalid")
		logger.Error("Expected body: ", expected)

		c.JSON(types.Http.C400().BadRequest(),
			types.EmptyResponse(
				"Invalid request body",
				"Expected body: "+expected,
			),
		)
		return
	}

	id := c.Param("id")
	filter := models.Filter.Create(c.Request.URL.Query())

	result := db.VulnerabilityType.PatchByID(id, body, filter)

	if result.IsErr() {
		err := result.Error()
		cerror := err.(*types.HttpError)
		c.JSON(cerror.Code,
			types.EmptyResponse(
				cerror.Msg(),
				cerror.Details(),
			),
		)
		return
	}

	vulnerabilityType := result.Value()
	c.JSON(types.Http.C200().Ok(),
		types.Response(
			vulnerabilityType.ToResponse(),
			"",
		),
	)
}

func (vulnerabilityTypeType) DeleteByID(c *gin.Context) {
	id := c.Param("id")
	logger.Debug("Deleting vulnerabilityType by ID: ", id)
	filter := models.Filter.Create(c.Request.URL.Query())

	result := db.VulnerabilityType.DeleteByID(id, filter)

	if result.IsErr() {
		err := result.Error()
		cerror := err.(*types.HttpError)
		c.JSON(cerror.Code,
			types.EmptyResponse(
				cerror.Msg(),
				cerror.Details(),
			),
		)
		return
	}

	data := result.Value().ToResponse()

	c.JSON(types.Http.C200().Accepted(),
		types.Response(
			data,
			"VulnerabilityType marked for deletion",
		),
	)
}
